#!/usr/bin/env php
<?php


namespace Kamille\Utils\Exception {


    /**
     *
     * The user has done something wrong.
     *
     *
     * The idea of an user error exception is to display only
     * the message (i.e. not the trace as with a normal exception).
     *
     * In other words, we use the user error exception as a way
     * to signal an error in the application.
     * (exceptions are handy because they allow to jump over many
     * if and/or foreach blocks at once).
     *
     *
     */
    class UserErrorException extends \Exception
    {

    }
}


namespace Bat {


    use CopyDir\AuthorCopyDirUtil;

    class FileSystemTool
    {

        /**
         * Removes an entry from the filesystem.
         * The entry can be:
         *
         * - a link, then the link only is removed (not the target)
         * - a file, then the file is removed
         * - a directory, the the directory is removed recursively
         *
         * It is considered a success when the entry doesn't exist on the filesystem at the end,
         * and a failure otherwise.
         *
         * By default, the method throws an exception in case of failure.
         *
         * If you set the throwEx flag to false, then this method will return true in case of success,
         * and false in case of failure.
         *
         */
        public static function remove($file, $throwEx = true)
        {
            if (false === is_link($file)) {
                if (file_exists($file)) {
                    return self::_remove($file, $throwEx);
                } else {
                    return true;
                }
            } else {
                if (false === unlink($file)) {
                    return self::_oops("Cannot remove link $file", $throwEx);
                }
                return true;
            }
        }

        /**
         * Copies a directory to a given location.
         */
        public static function copyDir($src, $target, $preservePerms = false, &$errors = [])
        {
            $o = AuthorCopyDirUtil::create();
            $o->setPreservePerms($preservePerms);
            $ret = $o->copyDir($src, $target);
            $errors = $o->getErrors();
            return $ret;
        }




        //------------------------------------------------------------------------------/
        //
        //------------------------------------------------------------------------------/
        private static function _oops($m, $throwEx = true)
        {
            if (true === $throwEx) {
                throw new \Exception($m);
            }
            return false;
        }

        private static function _remove($file, $throwEx = true)
        {
            if (is_dir($file) && !is_link($file)) {
                if (is_readable($file)) {
                    $files = new \FilesystemIterator($file,
                        \FilesystemIterator::KEY_AS_PATHNAME |
                        \FilesystemIterator::CURRENT_AS_FILEINFO |
                        \FilesystemIterator::SKIP_DOTS
                    );
                    foreach ($files as $f) {
                        self::_remove($f, $throwEx);
                    }
                    if (false === rmdir($file)) {
                        return self::_oops("Cannot remove dir $file", $throwEx);
                    }
                    return true;
                } else {
                    return self::_oops("Cannot remove unreadable dir $file", $throwEx);
                }
            } else {
                if (true === is_file($file) || true === is_link($file)) {
                    if (false === unlink($file)) {
                        if (true === is_link($file)) {
                            return self::_oops("Cannot remove link $file", $throwEx);
                        }
                        return self::_oops("Cannot remove file $file", $throwEx);
                    }
                    return true;
                }
            }
        }
    }
}


namespace CopyDir {


    /*
     * LingTalfi 2015-10-19
     */
    use CopyDir\Exception\CopyDirException;

    class CopyDirUtil
    {

        /**
         * @var bool: if true, throws an exception if anything goes wrong
         *            if false (default), put errors in the errors array
         */
        private $strictMode;
        private $errors;
        private $followFileLinks;
        private $followDirLinks;

        /**
         *    void      f (  str:src,  str:target,  &str:errMsg )
         *
         * This callback is called whenever we try to make a copy of a dir to an already existing
         * entry which is either a file or a broken link.
         *
         * The default behaviour, if the callback is not defined (or do nothing) is to skip the copying of the
         * directory and to add an error message indicating that an entry with the same name already existed.
         *
         * The callback has the opportunity to change this behaviour by changing the errMsg that will be produced,
         * and/or by removing the existing entry and create a valid directory instead.
         * Once the callback has been executed, the class will re-check whether or not a directory exist,
         * and will use the new directory if found.
         *
         * If the directory has been recreated, the errMsg should be the empty string.
         *
         *
         */
        private $onDirConflict;

        /**
         * Same mechanism as onDirConflict, except that the target can be any type of file (file, symlink, dir).
         * And also, there is no double checking that the file exists after the callback is called, the class
         * just cares about the errMsg which can be either non empty or empty.
         */
        private $onFileConflict;
        private $onFileLinkConflict;
        private $onDirLinkConflict;
        private $onBrokenLinkConflict;

        /**
         * void     f ( str:baseName, str:src, str:target, bool:&continue=true )
         *
         * This callback is triggered before directory entries are processed.
         * It was originally designed to serve as a pre-filter (to filter out undesirable entries).
         *
         * If the callback sets the continue flag to false, the entry will be skip.
         *
         *
         */
        private $onCopyBefore;
        /**
         * void     f ( str:src, str:target )
         *
         * This callback is triggered:
         * - every time a src directory is mapped to a target directory
         * - every time a try to copy a src directory entry into its target correspondent is done
         *
         * This callback was originally designed to allow post chmoding of the target entries.
         *
         */
        private $onCopyAfter;

        public function __construct()
        {
            $this->strictMode = false;
            $this->errors = [];
            $this->followFileLinks = false;
            $this->followDirLinks = false;
            $this->onDirConflict = false;
            $this->onFileConflict = false;
            $this->onFileLinkConflict = false;
            $this->onDirLinkConflict = false;
            $this->onBrokenLinkConflict = false;
            $this->onCopyBefore = false;
            $this->onCopyAfter = false;
        }


        public static function create()
        {
            return new static();
        }


        /**
         * Copies/maps src to target.
         *
         * @return true if no error occurred, false otherwise,
         *              or throws an exception if an error occurs and strict mode is on (strict mode is on by default).
         * @throws CopyDirException
         */
        public function copyDir($src, $target)
        {
            if (2 === func_num_args()) {
                $this->errors = [];
            }

            if (is_dir($src)) {
                if (is_readable($src)) {

                    $cleanTarget = true;
                    // case where the target is a file or a broken link (it's supposed to be either a file or not exist)
                    if (
                        is_file($target) ||
                        (is_link($target) && (false === is_file($target) && false === is_dir($target)))
                    ) {
                        $errMsg = "Cannot create dir $target, because an entry (of type file or broken link) with the same name was already found";
                        if (is_callable($this->onDirConflict)) {
                            call_user_func_array($this->onDirConflict, [$src, $target, &$errMsg]);
                        }
                        clearstatcache(); // not sure if needed for is_dir($target) call, so in doubt...
                        if (!is_dir($target)) {
                            $cleanTarget = false;
                        }
                        if ($errMsg) {
                            $this->error($errMsg);
                        }
                    }


                    if (true === $cleanTarget) {

                        $targetIsDir = true;
                        if (!is_dir($target)) {
                            if (false === mkdir($target, 0777, true)) {
                                $this->error("Couldn't create the target dir: $target");
                                $targetIsDir = false;
                            }
                        }
                        if (true === $targetIsDir) {

                            $this->_onCopyAfter($src, $target);


                            if (is_writable($target)) {
                                $files = scandir($src);
                                foreach ($files as $baseName) {
                                    if ('.' !== $baseName && '..' !== $baseName) {


                                        $file = $src . '/' . $baseName;
                                        $targetFile = $target . '/' . $baseName;


                                        $continue = true;
                                        if (is_callable($this->onCopyBefore)) {
                                            call_user_func_array($this->onCopyBefore, [$baseName, $file, $targetFile, &$continue]);
                                        }


                                        if (true === $continue) {

                                            $isProcessedAsLink = false;
                                            if (is_link($file)) {
                                                if (is_file($file)) {
                                                    if (false === $this->followFileLinks) {
                                                        $isProcessedAsLink = true;
                                                        $this->copyFileLink($file, $targetFile);
                                                    }
                                                } elseif (is_dir($file)) {
                                                    if (false === $this->followDirLinks) {
                                                        $isProcessedAsLink = true;
                                                        $this->copyDirLink($file, $targetFile);
                                                    }
                                                } else {
                                                    // broken link
                                                    $isProcessedAsLink = true;
                                                    $this->copyBrokenLink($file, $targetFile);
                                                }
                                            }


                                            if (false === $isProcessedAsLink) {
                                                if (is_file($file)) {
                                                    $this->copyFile($file, $targetFile);
                                                } elseif (is_dir($file)) {
                                                    $this->copyDir($file, $targetFile, true);
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                $this->error("Target dir must be writable: $target");
                            }
                        }
                    }
                } else {
                    $this->error("src is not readable: $src");
                }
            } else {
                $this->error("src is not a dir: $src");
            }


            // handling errors
            if (true === $this->strictMode && $this->errors) {
                $m = 'The following errors have occurred: ' . implode(', ', $this->errors);
                $e = new CopyDirException($m);
                $e->errorArray = $this->errors;
                throw $e;
            }
            return (0 === count($this->errors));
        }



        //------------------------------------------------------------------------------/
        //
        //------------------------------------------------------------------------------/
        public function setStrictMode($strictMode)
        {
            $this->strictMode = (bool)$strictMode;
            return $this;
        }

        public function getErrors()
        {
            return $this->errors;
        }

        public function setFollowDirLinks($followDirLinks)
        {
            $this->followDirLinks = (bool)$followDirLinks;
            return $this;
        }

        public function setFollowFileLinks($followFileLinks)
        {
            $this->followFileLinks = (bool)$followFileLinks;
            return $this;
        }

        public function setOnBrokenLinkConflict($onBrokenLinkConflict)
        {
            $this->onBrokenLinkConflict = $onBrokenLinkConflict;
            return $this;
        }

        public function setOnCopyAfter($onCopyAfter)
        {
            $this->onCopyAfter = $onCopyAfter;
            return $this;
        }

        public function setOnCopyBefore($onCopyBefore)
        {
            $this->onCopyBefore = $onCopyBefore;
            return $this;
        }

        public function setOnDirConflict($onDirConflict)
        {
            $this->onDirConflict = $onDirConflict;
            return $this;
        }

        public function setOnDirLinkConflict($onDirLinkConflict)
        {
            $this->onDirLinkConflict = $onDirLinkConflict;
            return $this;
        }

        public function setOnFileConflict($onFileConflict)
        {
            $this->onFileConflict = $onFileConflict;
            return $this;
        }

        public function setOnFileLinkConflict($onFileLinkConflict)
        {
            $this->onFileLinkConflict = $onFileLinkConflict;
            return $this;
        }



        //------------------------------------------------------------------------------/
        //
        //------------------------------------------------------------------------------/
        private function copyFile($src, $target)
        {
            $this->copyThing($src, $target, "file", "onFileConflict");
        }

        private function copyFileLink($src, $target)
        {
            $this->copyThing($src, $target, "file link", "onFileLinkConflict");
        }

        private function copyDirLink($src, $target)
        {
            $this->copyThing($src, $target, "dir link", "onDirLinkConflict");
        }

        private function copyBrokenLink($src, $target)
        {
            $this->copyThing($src, $target, "broken link", "onBrokenLinkConflict");
        }


        private function copyThing($src, $target, $type, $callback)
        {
            if (!file_exists($target) && !is_link($target)) {
                switch ($type) {
                    case 'dir link':
                    case 'file link':
                    case 'broken link':
                        $link = readlink($src);
                        if (false === symlink($link, $target)) {
                            $this->error("Could not copy $type $src to $target");
                        }
                        break;
                    default:
                        if (false === copy($src, $target)) {
                            $this->error("Could not copy $type $src to $target");
                        }
                        break;
                }
            } else {
                $errMsg = "Couldn't create $type $target, because an entry with the same name already existed";
                $this->onConflict($src, $target, $errMsg, $callback, $type);
                if ($errMsg) {
                    $this->error($errMsg);
                }
            }
            $this->_onCopyAfter($src, $target);
        }


        //------------------------------------------------------------------------------/
        //
        //------------------------------------------------------------------------------/
        protected function onConflict($src, $target, &$errMsg, $callback, $type)
        {
            if (is_callable($this->$callback)) {
                call_user_func_array($this->$callback, [$src, $target, &$errMsg]);
            }
        }


        protected function _onCopyAfter($src, $target)
        {
            if (is_callable($this->onCopyAfter)) {
                call_user_func($this->onCopyAfter, $src, $target);
            }
        }

        protected function error($m)
        {
            $this->errors[] = $m;
        }
    }


    /*
     * LingTalfi 2015-10-19
     *
     * Features:
     * - on file conflict: if the target is a file, its content gets replaced with
     *          the content of the src.
     * - by default ignore conflict errors
     * - can handle mapping of permissions
     *
     *
     */

    class AuthorCopyDirUtil extends CopyDirUtil
    {

        private $applyPerms;
        private $applyOwner;
        private $ignoreConflictErrors;

        public function __construct()
        {
            parent::__construct();
            $this->applyOwner = false;
            $this->applyPerms = false;
            $this->ignoreConflictErrors = true;
        }

        public function setPreservePerms($bool)
        {
            $bool = (bool)$bool;
            $this->applyOwner = $bool;
            $this->applyPerms = $bool;
            return $this;
        }

        public function setIgnoreConflictErrors($ignoreConflictErrors)
        {
            $this->ignoreConflictErrors = (bool)$ignoreConflictErrors;
            return $this;
        }






        //------------------------------------------------------------------------------/
        //
        //------------------------------------------------------------------------------/
        protected function onConflict($src, $target, &$errMsg, $callback, $type)
        {
            if ('onFileConflict' === $callback) {
                if (is_file($target)) {
                    copy($src, $target);
                    $errMsg = null;
                }
            }
            if (true === $this->ignoreConflictErrors) {
                $errMsg = null;
            }
            parent::onConflict($src, $target, $errMsg, $callback, $type);
        }

        protected function _onCopyAfter($src, $target)
        {
            if (is_link($src) && false === is_file($src) && false === is_dir($src)) {
                // broken link case, we don't need to chmod it
            } else {
                if (true === $this->applyPerms) {
                    $octal = substr(sprintf('%o', fileperms($src)), -4);
                    if (false === chmod($target, octdec($octal))) {
                        $this->error("Cannot chmod $target with perms $octal");
                    }
                }
                if (true === $this->applyOwner) {
                    if (false !== ($owner = fileowner($src))) {
                        if (false !== ($ownerGroup = filegroup($src))) {
                            if (false === chown($target, $owner)) {
                                if (true === extension_loaded('posix')) {
                                    $owner = posix_getpwuid($owner)['name'];
                                }
                                $this->error("Could not chown for $target with owner=$owner");
                            }
                            if (false === chgrp($target, $ownerGroup)) {
                                if (true === extension_loaded('posix')) {
                                    $ownerGroup = posix_getgrgid($ownerGroup)['name'];
                                }
                                $this->error("Could not chgrp for $target with owner=$ownerGroup");
                            }

                        } else {
                            $this->error("Couldn't access group owner information for $src");
                        }
                    } else {
                        $this->error("Couldn't access file owner information for $src");
                    }
                }
            }
            parent::_onCopyAfter($src, $target);
        }


    }
}

namespace CopyDir\Exception {
    /*
     * LingTalfi 2015-10-19
     */

    class CopyDirException extends \Exception
    {


        public $errorArray;

        public function __construct($message = "", $code = 0, \Exception $previous = null)
        {
            parent::__construct($message, $code, $previous);
            $this->errorArray = [];
        }
    }
}


namespace KamilleNaiveImporter\Exception {
    class KamilleNaiveImporterException extends \Exception
    {
    }
}


namespace KamilleNaiveImporter\ImportSummary {


    /**
     * This object summarizes the result of the import operation.
     *
     * You get:
     * - statistical info
     * - error messages in case things went bad
     *
     */
    interface ImportSummaryInterface
    {

        public function isSuccessful();

        /**
         * Modules which have actually been replaced (overwritten)
         */
        public function getReimportedModules();

        public function getAlreadyImportedModules();

        public function getNotImportedModules();


        public function getErrorMessages();


        public function setReimportedModules(array $modules);

        public function setAlreadyImportedModules(array $modules);

        public function setNotImportedModules(array $modules);


        public function setErrorMessages(array $errorMessages);
    }


    use KamilleNaiveImporter\InstallSummary\InstallSummaryInterface;

    class ImportSummary implements ImportSummaryInterface
    {
        private $successful;
        private $reImportedModules;
        private $alreadyImportedModules;
        private $notImportedModules;
        private $errorMessages;


        public function __construct()
        {
            $this->reImportedModules = [];
            $this->notImportedModules = [];
            $this->alreadyImportedModules = [];
            $this->errorMessages = [];
            $this->successful = false;
        }

        public static function create()
        {
            return new static();
        }


        public function isSuccessful()
        {
            return $this->successful;
        }

        /**
         * Modules which have actually been replaced (overwritten)
         */
        public function getReimportedModules()
        {
            return $this->reImportedModules;
        }


        public function getNotImportedModules()
        {
            return $this->notImportedModules;
        }

        public function getAlreadyImportedModules()
        {
            return $this->alreadyImportedModules;
        }

        public function getErrorMessages()
        {
            return $this->errorMessages;
        }



        //--------------------------------------------
        //
        //--------------------------------------------
        public function setSuccessful($successful)
        {
            $this->successful = $successful;
            return $this;
        }

        public function setReimportedModules(array $reImportedModules)
        {
            $this->reImportedModules = $reImportedModules;
            return $this;
        }

        public function setNotImportedModules(array $notImportedModules)
        {
            $this->notImportedModules = $notImportedModules;
            return $this;
        }

        public function setAlreadyImportedModules(array $alreadyImportedModules)
        {
            $this->alreadyImportedModules = $alreadyImportedModules;
            return $this;
        }

        public function setErrorMessages(array $errorMessages)
        {
            $this->errorMessages = $errorMessages;
            return $this;
        }

        //--------------------------------------------
        //
        //--------------------------------------------
        public function addAlreadyImportedModule($module)
        {
            $this->alreadyImportedModules[] = $module;
            return $this;
        }

        public function addNotImportedModule($module)
        {
            $this->notImportedModules[] = $module;
            return $this;
        }

        public function addReimportedModule($module)
        {
            $this->reImportedModules[] = $module;
            return $this;
        }

        public function addErrorMessage($msg)
        {
            $this->errorMessages[] = $msg;
            return $this;
        }


    }
}


namespace KamilleNaiveImporter\Importer {


    use KamilleNaiveImporter\ImportSummary\ImportSummaryInterface;

    interface KamilleImporterInterface
    {


        /**
         * Return the importer id
         * @return string
         */
        public function getImporterId();

        /**
         * @param $moduleName
         * @return bool
         */
        public function canImport($moduleName);


        /**
         * @param $moduleName
         * @return array of flattened (cycling references resolved) dependencies, including the moduleName itself
         */
        public function getDependencyTree($moduleName);


        /**
         * Import the given module(s) in the class-modules directory.
         * It overwrites existing modules if force is set to true
         *
         * @return ImportSummaryInterface
         */
        public function import($modulesDir, $moduleName, $force = false);


        public function listAvailableModules();
    }


    use Bat\FileSystemTool;
    use KamilleNaiveImporter\ImportSummary\ImportSummary;
    use KamilleNaiveImporter\KamilleNaiveImporter;

    class KamilleWidgetsKamilleImporter implements KamilleImporterInterface
    {

        private static $dependencyMap = [
            "Connexion" => ["GentelellaWebDirectory"],
            "GentelellaWebDirectory" => [],
        ];

        public static function create()
        {
            return new static();
        }


        public function getImporterId()
        {
            return "KamilleWidgets";
        }

        public function getDependencyTree($moduleName)
        {
            $tree = [];
            $this->collectDependencyTree($moduleName, $tree);
            $tree = array_unique($tree);
            return $tree;
        }


        public function listAvailableModules()
        {
            return array_keys(self::$dependencyMap);
        }


        public function canImport($moduleName)
        {
            return array_key_exists($moduleName, self::$dependencyMap);
        }

        public function import($modulesDir, $moduleName, $force = false)
        {
            $success = false;
            $summary = ImportSummary::create();
            if (is_dir($modulesDir)) {
                $success = true;


                $tree = $this->getDependencyTree($moduleName);


                foreach ($tree as $module) {
                    $output = [];
                    $returnVar = 0;

                    $moduleDir = $modulesDir . "/" . $module;

                    if (file_exists($moduleDir)) {
                        if (true === $force) {
                            FileSystemTool::remove($moduleDir);
                        } else {
                            $summary->addAlreadyImportedModule($moduleName);
                            continue;
                        }
                    }
                    $cmd = 'cd "' . $modulesDir . '"; git clone https://github.com/KamilleModules/' . $moduleName . '.git';
                    exec($cmd, $output, $returnVar);
                    if (0 === $returnVar) {
                        $summary->addReimportedModule($moduleName);
                    } else {
                        $success = false;
                        $summary->addNotImportedModule($moduleName);
                    }
                }
            }
            $summary->setSuccessful($success);
            return $summary;
        }




        //--------------------------------------------
        //
        //--------------------------------------------
        private function collectDependencyTree($modules, array &$tree)
        {
            if (is_string($modules)) {
                $moduleName = $modules;
                $tree[] = $moduleName;
                if (array_key_exists($moduleName, self::$dependencyMap)) {
                    $deps = self::$dependencyMap[$moduleName];
                    foreach ($deps as $dep) {
                        if (!in_array($dep, $tree, true)) {
                            self::collectDependencyTree($dep, $tree);
                        }
                    }
                }
            } elseif (is_array($modules)) {
                foreach ($modules as $moduleName) {
                    $this->collectDependencyTree($moduleName, $tree);
                }
            }
        }

    }
}


namespace KamilleNaiveImporter\InstallSummary {


    use KamilleNaiveImporter\ImportSummary\ImportSummary;
    use KamilleNaiveImporter\ImportSummary\ImportSummaryInterface;

    interface InstallSummaryInterface extends ImportSummaryInterface
    {
        /**
         * Fresh installed modules
         */
        public function getNewlyInstalledModules();

        public function getAlreadyInstalledModules();

        /**
         * return modules left uninstalled after a call to an erroneous/buggy install command
         */
        public function getUninstalledModules();

        /**
         * return modules uninstalled via the uninstall command
         */
        public function getSuccessfullyUninstalledModules();
    }


    class InstallSummary extends ImportSummary implements InstallSummaryInterface
    {

        private $newlyInstalledModules;
        private $alreadyInstalledModules;
        private $uninstalledModules;
        private $successfullyUninstalledModules;


        public function __construct()
        {
            parent::__construct();
            $this->newlyInstalledModules = [];
            $this->alreadyInstalledModules = [];
            $this->uninstalledModules = [];
            $this->successfullyUninstalledModules = [];
        }


        public function getNewlyInstalledModules()
        {
            return $this->newlyInstalledModules;
        }

        public function getAlreadyInstalledModules()
        {
            return $this->alreadyInstalledModules;
        }

        public function getUninstalledModules()
        {
            return $this->uninstalledModules;
        }

        public function getSuccessfullyUninstalledModules()
        {
            return $this->successfullyUninstalledModules;
        }


        public function setNewlyInstalledModules(array $newlyInstalledModules)
        {
            $this->newlyInstalledModules = $newlyInstalledModules;
            return $this;
        }

        public function setAlreadyInstalledModules(array $alreadyInstalledModules)
        {
            $this->alreadyInstalledModules = $alreadyInstalledModules;
            return $this;
        }

        public function setUninstalledModules(array $uninstalledModules)
        {
            $this->uninstalledModules = $uninstalledModules;
            return $this;
        }

        public function setSuccessfullyUninstalledModules(array $successfullyUninstalledModules)
        {
            $this->successfullyUninstalledModules = $successfullyUninstalledModules;
            return $this;
        }

        //--------------------------------------------
        //
        //--------------------------------------------

        //--------------------------------------------
        //
        //--------------------------------------------
        public function addAlreadyInstalledModule($module)
        {
            $this->alreadyInstalledModules[] = $module;
            return $this;
        }

        public function addUninstalledModule($module)
        {
            $this->uninstalledModules[] = $module;
            return $this;
        }

        public function addNewlyInstalledModule($module)
        {
            $this->newlyInstalledModules[] = $module;
            return $this;
        }

        public function addSuccessfullyUninstalledModule($module)
        {
            $this->successfullyUninstalledModules[] = $module;
            return $this;
        }
    }
}


namespace Kamille\Utils\ModuleInstaller\Exception {
    class ModuleInstallerException extends \Exception
    {

    }
}


namespace Kamille\Utils\ModuleInstaller {


    use Kamille\Utils\ModuleInstaller\Exception\ModuleInstallerException;
    use Kamille\Module\ModuleInterface;
    use Kamille\Utils\StepTracker\StepTrackerAwareInterface;
    use Kamille\Utils\StepTracker\StepTrackerInterface;

    /**
     * This is a hacked version of the ModuleInstaller class (from the Kamille framework).
     * It works exactly the same, except on how to access the modules.txt file.
     *
     */
    class ModuleInstaller implements StepTrackerAwareInterface
    {

        private $file;
        private $appDir;
        private $stepTracker;


        public function install($moduleName)
        {
            $oClass = $this->getClassInstance($moduleName);
            if (null !== $this->stepTracker && $oClass instanceof StepTrackerAwareInterface) {
                $oClass->setStepTracker($this->stepTracker);
            }
            $oClass->install();
            $list = $this->getInstalledModulesList();
            if (!in_array($moduleName, $list)) {
                $list[] = $moduleName;
            }
            $this->writeList($list);
            return true;
        }

        public function uninstall($moduleName)
        {
            $oClass = $this->getClassInstance($moduleName);
            if (null !== $this->stepTracker && $oClass instanceof StepTrackerAwareInterface) {
                $oClass->setStepTracker($this->stepTracker);
            }
            $oClass->uninstall();
            $list = $this->getInstalledModulesList();
            unset($list[array_search($moduleName, $list)]);
            $this->writeList($list);
            return true;
        }

        public function isInstalled($moduleName)
        {
            $list = $this->getInstalledModulesList();
            return in_array($moduleName, $list, true);
        }

        public function getInstalledModulesList()
        {
            $ret = [];
            $f = $this->getFile();
            if (file_exists($f)) {
                $ret = file($f, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES);
                $ret = array_filter($ret);
            }
            return $ret;
        }


        public function setAppDir($appDir)
        {
            $this->appDir = $appDir;
            return $this;
        }

        public function setStepTracker(StepTrackerInterface $stepTracker)
        {
            $this->stepTracker = $stepTracker;
            return $this;
        }






        //--------------------------------------------
        //
        //--------------------------------------------
        private function getFile()
        {
            if (null === $this->file) {
                $this->file = $this->appDir . "/modules.txt";
            }
            return $this->file;
        }


        /**
         * @param $moduleName
         * @throws ModuleInstallerException
         */
        private function getClassInstance($moduleName)
        {
            $modulesDir = $this->appDir . "/class-modules/$moduleName";
            if (is_dir($modulesDir)) {
                $moduleFile = $modulesDir . "/$moduleName" . "Module.php";
                if (file_exists($moduleFile)) {

                    require_once $moduleFile;


                    $className = $moduleName . '\\' . $moduleName . "Module";
                    $oClass = new $className();
                    if ($oClass instanceof ModuleInterface) {

                        return $oClass;


                    } else {
                        throw new ModuleInstallerException(sprintf("$className must be an instance of ModuleInterface, instance of %s given", get_class($oClass)));
                    }
                } else {
                    throw new ModuleInstallerException("module file not found: $moduleFile");
                }
            } else {
                throw new ModuleInstallerException("module not imported yet: $moduleName. Please import the module before you can install it");
            }
        }


        private function writeList(array $list)
        {
            $f = $this->getFile();
            file_put_contents($f, implode(PHP_EOL, $list));
        }
    }


    /**
     * This is a module installer for the kamille framework.
     * See motivation notes in "implementation notes" from the kaminos framework.
     */
    interface ModuleInstallerInterface
    {


        /**
         * Note: if a module is already installed, the module will
         * be reinstalled.
         * (one should use the isInstalled method to check whether or not
         * a module is already installed)
         *
         *
         *
         * @throws ModuleInstallerException when something wrong happens
         * @return true if the installation of the module was successful
         */
        public function install($moduleName);

        /**
         * @throws ModuleInstallerException when something wrong happens
         * @return true if the uninstallation of the module was successful
         */
        public function uninstall($moduleName);

        /**
         * @return bool
         */
        public function isInstalled($moduleName);


        /**
         * @return array, list of installed module names
         */
        public function getInstalledModulesList();


    }
}


namespace Kamille\Module\Exception {
    class ModuleException extends \Exception
    {

    }
}


namespace Kamille\Module {

    use Kamille\Module\Exception\ModuleException;

    interface ModuleInterface
    {


        /**
         * @throws ModuleException when something wrong happens
         * @return true if the install process is successful
         */
        public function install();


        /**
         * @throws ModuleException when something wrong happens
         * @return true if the uninstall process is successful
         */
        public function uninstall();

    }


    use Kamille\Utils\StepTracker\StepTrackerAwareInterface;
    use Kamille\Utils\StepTracker\StepTrackerInterface;

    abstract class StepTrackerAwareModule implements ModuleInterface, StepTrackerAwareInterface
    {


        /**
         * @var StepTrackerInterface $stepTracker
         */
        protected $stepTracker;

        public function setStepTracker(StepTrackerInterface $stepTracker)
        {
            $this->stepTracker = $stepTracker;
            $stepTracker->setSteps($this->getStepsList());
            return $this;
        }


        /**
         * @return array of steps id => label
         */
        abstract protected function getStepsList();


    }
}


namespace Kamille\Services {


    use Kamille\Utils\ModuleInstaller\ModuleInstaller;
    use Kamille\Utils\ModuleInstaller\ModuleInstallerInterface;

    class XModuleInstaller
    {

        private static $inst;


        /**
         * @return ModuleInstallerInterface
         */
        public static function inst()
        {
            if (null === self::$inst) {
                self::$inst = new ModuleInstaller();
            }
            return self::$inst;
        }
    }
}


namespace ProgramPrinter {


    class ProgramPrinter implements ProgramPrinterInterface
    {
        public static function create()
        {
            return new static();
        }


        public function error($msg, $br = true)
        {
            echo "\e[31m$msg\e[0m";
            if (true === $br) {
                echo PHP_EOL;
            }
        }

        public function success($msg, $br = true)
        {
            echo "\e[32m$msg\e[0m";
            if (true === $br) {
                echo PHP_EOL;
            }
        }

        public function info($msg, $br = true)
        {
            echo "\e[34m$msg\e[0m";
            if (true === $br) {
                echo PHP_EOL;
            }
        }

        public function warn($msg, $br = true)
        {
            // 1;31: light red
            // 1;33: yellow
            echo "\e[31m$msg\e[0m";
            if (true === $br) {
                echo PHP_EOL;
            }
        }

        public function help()
        {
            echo <<<HELP
\e[34m        
Usage
-------
kamille import {module} {importerId}?                    # import one module and dependencies, skip already existing module(s)/dependencies
kamille import -f {module} {importerId}?                 # import one module and dependencies, replace already existing module(s)/dependencies
kamille install {module} {importerId}?                   # call the install method of the given module (it fails if the module is not imported already)
kamille install -f {module} {importerId}?                # import and install one module and all its dependencies 
kamille uninstall {module} {importerId}?                 # call the uninstall method of the given module 
kamille list {importerId}?                               # list available modules
kamille listimported                                     # list imported modules
kamille listinstalled                                    # list installed modules
kamille setmodulesrelpath                                # set the relative path to the modules directory (from the app directory)
kamille getmodulesrelpath                                # get the relative path to the modules directory (from the app directory)
kamille clean                                            # removes the .git, .gitignore, .idea and .DS_Store files at the top level of your application's directory

For instance: 
    kamille import Connexion
    kamille import Connexion KamilleWidgets
    kamille import -f Connexion 
    kamille import -f Connexion KamilleWidgets
    kamille install Connexion 
    kamille install Connexion KamilleWidgets 
    kamille install -f Connexion 
    kamille install -f Connexion KamilleWidgets
    kamille uninstall Connexion 
    kamille uninstall Connexion KamilleWidgets
    kamille list 
    kamille list KamilleWidgets
    kamille listimported 
    kamille listinstalled                      
    kamille setmodulesrelpath
    kamille getmodulesrelpath
    kamille clean
    
    
Options
-------------
-f: when used with the import keyword, force overwriting of existing modules and dependencies. If not set, the Importer will skip existing planets/dependencies.
    when used with the install keyword, force the importing (in force mode too) of the modules
    

\e[0m
HELP;
        }


        public function say($msg, $br = true)
        {
            echo $msg;
            if (true === $br) {
                echo PHP_EOL;
            }
        }

    }


    interface ProgramPrinterAwareInterface
    {
        public function setProgramPrinter(ProgramPrinterInterface $printer);
    }


    interface ProgramPrinterInterface
    {
        public function error($msg, $br = true);

        public function success($msg, $br = true);

        public function warn($msg, $br = true);

        public function info($msg, $br = true);

        public function help();

        public function say($msg, $br = true);
    }
}


namespace ProgramStorage {


    class ProgramStorage
    {


        public static function create()
        {
            return new static();
        }

        public function setModulesDirRelativePath($path)
        {
            if (false !== file_put_contents($this->getStorageFile(), $path)) {
                return true;
            }
            return false;
        }


        public function getModulesDirRelativePath()
        {
            $file = $this->getStorageFile();
            if (file_exists($file)) {
                return trim(file_get_contents($file));
            }
            return false;
        }

        //--------------------------------------------
        //
        //--------------------------------------------
        private function getStorageFile()
        {
            return __DIR__ . "/program-storage.txt";
        }
    }

}


namespace Tools {


    use Bat\FileSystemTool;
    use ProgramPrinter\ProgramPrinter;
    use ProgramPrinter\ProgramPrinterInterface;

    class CleanerTool
    {
        private $printer;
        private $filesToBeCleaned;
        private $dirsToBeCleaned;


        public function __construct()
        {
            $this->filesToBeCleaned = [
                '.gitignore',
                '.DS_Store',
            ];
            $this->dirsToBeCleaned = [
                '.idea',
                '.git',
            ];
        }

        public static function create()
        {
            return new static();
        }

        public function setFilesToBeCleaned($filesToBeCleaned)
        {
            $this->filesToBeCleaned = $filesToBeCleaned;
            return $this;
        }

        public function setDirsToBeCleaned($dirsToBeCleaned)
        {
            $this->dirsToBeCleaned = $dirsToBeCleaned;
            return $this;
        }


        public function setPrinter(ProgramPrinterInterface $printer)
        {
            $this->printer = $printer;
            return $this;
        }


        public function clean($targetDir)
        {
            $printer = $this->getPrinter();
            if (file_exists($targetDir)) {

                $modules = $this->getModulesNames($targetDir);
                foreach ($modules as $module) {

                    $d = $targetDir . "/" . $module;

                    foreach ($this->filesToBeCleaned as $_f) {
                        $f = $d . "/$_f";
                        if (file_exists($f)) {
                            unlink($f);
                        }
                    }

                    foreach ($this->dirsToBeCleaned as $_f) {
                        $f = $d . "/$_f";
                        if (is_dir($f)) {
                            FileSystemTool::remove($f);
                        }
                    }
                }
            } else {
                $printer->error("target planets directory does not exist: $targetDir");
            }
        }


        //--------------------------------------------
        //
        //--------------------------------------------
        private function getModulesNames($targetDir)
        {

            $files = scandir($targetDir);
            return array_filter($files, function ($v) {
                if (false !== strpos($v, '.')) {
                    return false;
                }
                return true;
            });
        }

        private function getPrinter()
        {
            if (null === $this->printer) {
                $this->printer = ProgramPrinter::create();
            }
            return $this->printer;
        }
    }
}


namespace KamilleNaiveImporter {



    use Kamille\Utils\Exception\UserErrorException;
    use Kamille\Utils\ModuleInstaller\ModuleInstaller;
    use Kamille\Utils\ModuleInstaller\ModuleInstallerInterface;
    use Kamille\Utils\StepTracker\ConsoleStepTracker;
    use Kamille\Utils\StepTracker\StepTrackerAwareInterface;
    use KamilleNaiveImporter\Importer\KamilleImporterInterface;
    use KamilleNaiveImporter\InstallSummary\InstallSummary;
    use KamilleNaiveImporter\InstallSummary\InstallSummaryInterface;
    use ProgramPrinter\ProgramPrinter;
    use ProgramPrinter\ProgramPrinterInterface;
    use KamilleNaiveImporter\ImportSummary\ImportSummary;
    use KamilleNaiveImporter\ImportSummary\ImportSummaryInterface;

    /**
     * This is the naive importer for the kamille framework.
     * It is naive because it doesn't try to deal with version numbers (when importing a module),
     * it just uses the latest version available.
     *
     *
     * What you can do with this class is:
     *
     *
     * - import module(s)
     * - list installed/imported modules
     *
     */
    class KamilleNaiveImporter
    {


        private $appDir;
        private $modulesRelativePath;

        /**
         * The value of the force flag.
         * By default, it's false/
         *
         */
        private $_forceImport;
        private $printer;

        /**
         * @var ModuleInstallerInterface
         */
        private $moduleInstaller;


        /**
         * @var KamilleImporterInterface[]
         */
        private $importers;


        public function __construct()
        {
            $this->modulesRelativePath = "class-modules";
            $this->importers = [];
            $this->_forceImport = false;
        }

        public static function create()
        {
            return new static();
        }

        public function setAppDir($appDir)
        {
            $this->appDir = $appDir;
            return $this;
        }

        public function setModulesRelativePath($modulesRelativePath)
        {
            $this->modulesRelativePath = $modulesRelativePath;
            return $this;
        }

        public function setProgramPrinter(ProgramPrinterInterface $printer)
        {
            $this->printer = $printer;
            return $this;
        }


        public function addImporter(KamilleImporterInterface $importer)
        {
            $this->importers[] = $importer;
            return $this;
        }

        public function forceImport($forceImport)
        {
            $this->_forceImport = $forceImport;
            return $this;
        }


        /**
         * Import a module and its dependencies.
         * If the force flag is set to true, then it replaces already existing imported modules.
         * Otherwise, it skips them.
         *
         *
         * @param $moduleName
         * @param null $importerId
         * @return ImportSummaryInterface
         * @throws UserErrorException
         */
        public function import($moduleName, $importerId = null)
        {
            if (null === $this->appDir) {
                throw new UserErrorException("appDir not set");
            }

            $modulesDir = $this->appDir . "/" . $this->modulesRelativePath;

            foreach ($this->importers as $importer) {
                if (
                    null === $importerId ||
                    (null !== $importerId && $importerId === $importer->getImporterId())
                ) {
                    if (true === $importer->canImport($moduleName)) {
                        $summary = $importer->import($modulesDir, $moduleName, $this->_forceImport);
                        return $summary;
                    }
                }
            }
            $summary = ImportSummary::create();
            $summary->setSuccessful(false);
            $summary->setUninstalledModules([$moduleName]);
            return $summary;
        }


        public function install($moduleName, $importerId = null)
        {
            if (null === $this->appDir) {
                throw new UserErrorException("appDir not set");
            }
            $force = $this->_forceImport;
            if (false === $force) {
                $availableModules = $this->getAvailableModules($importerId);
                if (in_array($moduleName, $availableModules, true)) {
                    $listImported = $this->getImportedModules();
                    if (in_array($moduleName, $listImported, true)) {
                        $summary = $this->installModule($moduleName);
                    } else {
                        throw new UserErrorException("This module is not imported: $moduleName. Please import it first (or use the -f flag with the install command)");
                    }
                } else {
                    throw new UserErrorException("This module is not available with importer $importerId");
                }
            } else {
                $importSummary = $this->import($moduleName, $importerId);
                if (true === $importSummary->isSuccessful()) {
                    $summaries = [];
                    $list = $importSummary->getReimportedModules();
                    foreach ($list as $item) {
                        $summaries[] = $this->installModule($item);
                    }
                    $summary = $this->mergeInstallSummaries($summaries);
                    $summary = $this->mergeImportSummaryIntoInstallSummary($importSummary, $summary);
                } else {
                    $summary = InstallSummary::create();
                    $summary->setSuccessful(false);
                    $summary->setNotImportedModules([$moduleName]);
                    $summary->addUninstalledModule($moduleName);
                }
            }
            return $summary;
        }


        public function uninstall($moduleName, $importerId = null)
        {
            if (null === $this->appDir) {
                throw new UserErrorException("appDir not set");
            }

            $availableModules = $this->getAvailableModules($importerId);
            if (in_array($moduleName, $availableModules, true)) {
                $listImported = $this->getImportedModules();
                if (in_array($moduleName, $listImported, true)) {
                    $summary = $this->uninstallModule($moduleName, $importerId);
                } else {
                    throw new UserErrorException("This module is not imported: $moduleName. Therefore it cannot be uninstalled");
                }
            } else {
                throw new UserErrorException("This module is not available with importer $importerId");
            }
            return $summary;
        }


        public function listAvailableModules($importerId = null)
        {
            $printer = $this->getPrinter();
            $modules = $this->getAvailableModulesByImporter($importerId);
            if (count($modules) > 0) {
                foreach ($modules as $importerId => $importerModules) {
                    echo $printer->info("Importer " . $importerId . ":");
                    foreach ($importerModules as $moduleName) {
                        echo "- " . $moduleName . PHP_EOL;
                    }
                }
            }
        }

        public function listImportedModules()
        {
            $printer = $this->getPrinter();
            $modulesDir = $this->appDir . "/" . $this->modulesRelativePath;
            if (!is_dir($modulesDir)) {
                @mkdir($modulesDir, 0777, true);
            }
            $list = $this->getImportedModules();
            foreach ($list as $moduleName) {
                $printer->say("- $moduleName");
            }
        }


        public function listInstalledModules()
        {
            $printer = $this->getPrinter();
            // assuming the application uses XModuleInstaller as the module installer
            $f = $this->appDir . "/modules.txt";
            $ret = [];
            if (file_exists($f)) {
                $ret = file($f, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES);
                $ret = array_filter($ret);
            }

            foreach ($ret as $moduleName) {
                $printer->say("- $moduleName");
            }
        }




        //--------------------------------------------
        //
        //--------------------------------------------
        protected function getAvailableModules($importerId = null)
        {
            $modules = [];
            foreach ($this->importers as $importer) {
                if (
                    null === $importerId ||
                    (null !== $importerId && $importerId === $importer->getImporterId())
                ) {
                    $modules = array_merge($modules, $importer->listAvailableModules());

                }
            }
            $modules = array_unique($modules);
            return $modules;
        }

        protected function getAvailableModulesByImporter($importerId = null)
        {
            $modules = [];
            foreach ($this->importers as $importer) {
                if (
                    null === $importerId ||
                    (null !== $importerId && $importerId === $importer->getImporterId())
                ) {

                    $id = $importer->getImporterId();
                    if (!array_key_exists($id, $modules)) {
                        $modules[$id] = [];
                    }
                    $modules[$id] = array_merge($modules[$id], $importer->listAvailableModules());
                }
            }
            return $modules;
        }

        //--------------------------------------------
        //
        //--------------------------------------------

        private function getImportedModules()
        {
            $modulesDir = $this->appDir . "/" . $this->modulesRelativePath;
            $list = [];
            if (is_dir($modulesDir)) {
                $files = scandir($modulesDir);
                foreach ($files as $f) {
                    $file = $modulesDir . "/" . $f;
                    if ('.' !== $f && '..' !== $f) {
                        if (is_dir($file)) {
                            $list[] = $f;
                        }
                    }
                }
            }
            return $list;
        }


        private function mergeImportSummaryIntoInstallSummary(ImportSummaryInterface $importSummary, InstallSummaryInterface $installSummary)
        {

            $alreadyImportedModules = array_merge($importSummary->getAlreadyImportedModules(), $installSummary->getAlreadyImportedModules());
            $notImportedModules = array_merge($importSummary->getNotImportedModules(), $installSummary->getNotImportedModules());
            $reimportedModules = array_merge($importSummary->getReimportedModules(), $installSummary->getReimportedModules());
            $errorMessages = array_merge($importSummary->getErrorMessages(), $installSummary->getErrorMessages());

            $alreadyImportedModules = array_unique($alreadyImportedModules);
            $notImportedModules = array_unique($notImportedModules);
            $reimportedModules = array_unique($reimportedModules);
            $errorMessages = array_unique($errorMessages);


            $installSummary->setAlreadyImportedModules($alreadyImportedModules);
            $installSummary->setReimportedModules($reimportedModules);
            $installSummary->setNotImportedModules($notImportedModules);
            $installSummary->setErrorMessages($errorMessages);
            return $installSummary;
        }


        private function mergeInstallSummaries(array $summaries)
        {

            $errorMessages = [];
            $alreadyImportedModules = [];
            $notImportedModules = [];
            $reimportedModules = [];
            $alreadyInstalledModules = [];
            $newlyInstalledModules = [];
            $uninstalledModules = [];
            $successfullyUninstalledModules = [];
            $successful = true;

            foreach ($summaries as $summary) {
                /**
                 * @var InstallSummaryInterface $summary
                 */
                $errorMessages = array_merge($errorMessages, $summary->getErrorMessages());
                $alreadyImportedModules = array_merge($alreadyImportedModules, $summary->getAlreadyImportedModules());
                $notImportedModules = array_merge($notImportedModules, $summary->getNotImportedModules());
                $reimportedModules = array_merge($reimportedModules, $summary->getReimportedModules());
                $alreadyInstalledModules = array_merge($alreadyInstalledModules, $summary->getAlreadyInstalledModules());
                $newlyInstalledModules = array_merge($newlyInstalledModules, $summary->getNewlyInstalledModules());
                $uninstalledModules = array_merge($uninstalledModules, $summary->getUninstalledModules());
                $successfullyUninstalledModules = array_merge($successfullyUninstalledModules, $summary->getSuccessfullyUninstalledModules());

                if (false === $summary->isSuccessful()) {
                    $successful = false;
                }
            }


            $errorMessages = array_unique($errorMessages);
            $alreadyImportedModules = array_unique($alreadyImportedModules);
            $notImportedModules = array_unique($notImportedModules);
            $reimportedModules = array_unique($reimportedModules);
            $alreadyInstalledModules = array_unique($alreadyInstalledModules);
            $newlyInstalledModules = array_unique($newlyInstalledModules);
            $uninstalledModules = array_unique($uninstalledModules);
            $successfullyUninstalledModules = array_unique($successfullyUninstalledModules);

            return InstallSummary::create()
                ->setErrorMessages($errorMessages)
                ->setSuccessfullyUninstalledModules($successfullyUninstalledModules)
                ->setUninstalledModules($uninstalledModules)
                ->setNewlyInstalledModules($newlyInstalledModules)
                ->setAlreadyInstalledModules($alreadyInstalledModules)
                ->setAlreadyImportedModules($alreadyImportedModules)
                ->setNotImportedModules($notImportedModules)
                ->setReimportedModules($reimportedModules)
                ->setSuccessful($successful);

        }


        private function installModule($moduleName)
        {



            $moduleInstaller = $this->getModuleInstaller();
            if ($moduleInstaller instanceof StepTrackerAwareInterface) {
                $moduleInstaller->setStepTracker($this->getStepTracker());
            }
            //
            $isSuccessful = false;
            $alreadyInstalled = false;
            $errorMessage = null;
            if (false === $moduleInstaller->isInstalled($moduleName)) {
                try {
                    $this->getPrinter()->info("Installing module $moduleName");
                    if (true === $moduleInstaller->install($moduleName)) {
                        $isSuccessful = true;
                    }
                } catch (\Exception $e) {
                    $isSuccessful = false;
                    $errorMessage = $e->getMessage();
                }

            } else {
                $isSuccessful = true;
                $alreadyInstalled = true;
            }


            $summary = InstallSummary::create();
            $summary->setSuccessful($isSuccessful);
            if (true === $isSuccessful) {
                if (true === $alreadyInstalled) {
                    $summary->addAlreadyInstalledModule($moduleName);
                } else {
                    $summary->addNewlyInstalledModule($moduleName);
                }
            } else {
                $summary->addUninstalledModule($moduleName);
                if (null !== $errorMessage) {
                    $summary->addErrorMessage($errorMessage);
                }
            }
            //
            return $summary;
        }


        private function uninstallModule($moduleName)
        {

            $moduleInstaller = $this->getModuleInstaller();
            if ($moduleInstaller instanceof StepTrackerAwareInterface) {
                $moduleInstaller->setStepTracker($this->getStepTracker());
            }
            //
            $isSuccessful = false;
            $successfullyUninstalled = false;
            $errorMessage = null;
            if (true === $moduleInstaller->isInstalled($moduleName)) {
                try {
                    $this->getPrinter()->info("Uninstalling module $moduleName");
                    if (true === $moduleInstaller->uninstall($moduleName)) {
                        $successfullyUninstalled = true;
                        $isSuccessful = true;
                    }
                } catch (\Exception $e) {
                    $isSuccessful = false;
                    $errorMessage = $e->getMessage();
                }

            } else {
                $isSuccessful = true;
            }


            $summary = InstallSummary::create();
            $summary->setSuccessful($isSuccessful);
            if (true === $isSuccessful) {
                if (true === $successfullyUninstalled) {
                    $summary->addSuccessfullyUninstalledModule($moduleName);
                }
            } else {
                if (null !== $errorMessage) {
                    $summary->addErrorMessage($errorMessage);
                }
            }
            //
            return $summary;
        }


        private function getStepTracker()
        {
            return ConsoleStepTracker::create();
        }

        /**
         * @return ProgramPrinterInterface
         */
        private function getPrinter()
        {
            if (null === $this->printer) {
                $this->printer = new ProgramPrinter();
            }
            return $this->printer;
        }

        /**
         * @return ModuleInstallerInterface
         */
        private function getModuleInstaller()
        {
            if (null === $this->moduleInstaller) {
                $this->moduleInstaller = new ModuleInstaller();
                $this->moduleInstaller->setAppDir($this->appDir);
            }
            return $this->moduleInstaller;
        }


    }
}


namespace Kamille\Utils\StepTracker {


    class StepTracker implements StepTrackerInterface
    {

        protected $steps;
        protected $onStepStartCb;
        protected $onStepStopCb;


        public function __construct()
        {
            $this->steps = [];
        }

        public static function create()
        {
            return new static();
        }


        public function getList()
        {
            return $this->steps;
        }

        public function startStep($stepId)
        {
            call_user_func($this->onStepStartCb, $stepId);
        }

        public function stopStep($stepId, $state = "done")
        {
            call_user_func($this->onStepStopCb, $stepId, $state);
        }

        public function setSteps(array $steps)
        {
            $this->steps = $steps;
            return $this;
        }


        //--------------------------------------------
        //
        //--------------------------------------------


        /**
         * fn ( stepId )
         */
        public function setOnStepStartCallback(callable $fn)
        {
            $this->onStepStartCb = $fn;
            return $this;
        }

        /**
         * fn ( stepId, state )
         *          state:done|aborted
         */
        public function setOnStepStopCallback(callable $fn)
        {
            $this->onStepStopCb = $fn;
            return $this;
        }
    }


    class ConsoleStepTracker extends StepTracker
    {
        public function __construct()
        {
            parent::__construct();

            $this->setOnStepStartCallback(function ($stepId) {
                $label = $this->steps[$stepId];
                $info = $this->getStepNumberInfo($stepId);


                $label = "step $info: $label ...";
                $this->printToOutput($label, false);
            });

            $this->setOnStepStopCallback(function ($stepId, $state) {


                if ('done' === $state) {
                    $state = "\033[0;32m$state" . "\033[0m";
                } else {
                    $state = "\033[0;31m$state" . "\033[0m";
                }

                $this->printToOutput(" " . $state, true);
            });
        }






        //--------------------------------------------
        //
        //--------------------------------------------
        private function printToOutput($msg, $newLine = false)
        {
            echo $msg;
            if (true === $newLine) {
                echo PHP_EOL;
            }
        }


        private function getStepNumberInfo($stepId)
        {
            $i = 1;
            $found = false;
            foreach ($this->steps as $id => $label) {
                if ($id === $stepId) {
                    $found = true;
                    break;
                }
                $i++;
            }

            if (true === $found) {
                $n = count($this->steps);
                return $i . "/" . $n;
            } else {
                throw new \RuntimeException("step not found: $stepId");
            }
        }
    }

    interface StepTrackerAwareInterface
    {

        public function setStepTracker(StepTrackerInterface $stepTracker);
    }


    interface StepTrackerInterface
    {
        /**
         * @return array, array of ordered steps identifier => label
         */
        public function getList();

        public function startStep($stepId);


        /**
         * state: done|aborted
         *
         */
        public function stopStep($stepId, $state = "done");

        /**
         * array of stepId => label
         */
        public function setSteps(array $steps);
    }


}


namespace {


    use Kamille\Utils\Exception\UserErrorException;
    use KamilleNaiveImporter\Importer\KamilleWidgetsKamilleImporter;
    use KamilleNaiveImporter\ImportSummary\ImportSummaryInterface;
    use KamilleNaiveImporter\InstallSummary\InstallSummaryInterface;
    use KamilleNaiveImporter\KamilleNaiveImporter;
    use ProgramPrinter\ProgramPrinter;
    use ProgramPrinter\ProgramPrinterInterface;
    use ProgramStorage\ProgramStorage;
    use Tools\CleanerTool;


    if (!function_exists('a')) {
        function a()
        {
            foreach (func_get_args() as $arg) {
                ob_start();
                var_dump($arg);
                $output = ob_get_clean();
                if ('1' !== ini_get('xdebug.default_enable')) {
                    $output = preg_replace("!\]\=\>\n(\s+)!m", "] => ", $output);
                }
                if ('cli' === PHP_SAPI) {
                    echo $output;
                } else {
                    echo '<pre>' . $output . '</pre>';
                }
            }
        }

        function az()
        {
            call_user_func_array('a', func_get_args());
            exit;
        }
    }


    function printImportSummary(ImportSummaryInterface $summary, ProgramPrinterInterface $printer)
    {
        //--------------------------------------------
        // PRINT SUMMARY
        //--------------------------------------------
        $successfull = $summary->isSuccessful();
        if (true === $successfull) {
            $printer->success("The import was successful");
        } else {
            $printer->error("The import was not successful");
        }
        $alreadyInstalled = $summary->getAlreadyImportedModules();
        $reinstalled = $summary->getReimportedModules();
        $uninstalled = $summary->getNotImportedModules();


        $cAlready = count($alreadyInstalled);
        $printer->say("$cAlready module(s) were already imported", false);
        if ($cAlready > 0) {
            $printer->say(": " . implode(", ", $alreadyInstalled));
        } else {
            $printer->say("");
        }

        $cReinstalled = count($reinstalled);
        $printer->say("$cReinstalled module(s) have been (re-)imported", false);
        if ($cReinstalled > 0) {
            $printer->say(": " . implode(", ", $reinstalled));
        } else {
            $printer->say("");
        }

        $cUninstalled = count($uninstalled);
        $printer->say("$cUninstalled module(s) couldn't be imported", false);
        if ($cUninstalled > 0) {
            $printer->say(": " . implode(", ", $uninstalled));
        } else {
            $printer->say("");
        }

    }

    function printInstallSummary(InstallSummaryInterface $summary, ProgramPrinterInterface $printer, $isUninstall = false)
    {

        $word = (true === $isUninstall) ? "uninstall" : "install";

        //--------------------------------------------
        // PRINT SUMMARY
        //--------------------------------------------
        $successfull = $summary->isSuccessful();
        if (true === $successfull) {
            $printer->success("The $word was successful");
        } else {
            $printer->error("The $word was not successful");
        }
        $alreadyInstalled = $summary->getAlreadyImportedModules();
        $reinstalled = $summary->getReimportedModules();
        $uninstalled = $summary->getNotImportedModules();


        $cAlready = count($alreadyInstalled);
        $printer->say("$cAlready module(s) were already imported", false);
        if ($cAlready > 0) {
            $printer->say(": " . implode(", ", $alreadyInstalled));
        } else {
            $printer->say("");
        }

        $cReinstalled = count($reinstalled);
        $printer->say("$cReinstalled module(s) have been (re-)imported", false);
        if ($cReinstalled > 0) {
            $printer->say(": " . implode(", ", $reinstalled));
        } else {
            $printer->say("");
        }

        $cUninstalled = count($uninstalled);
        $printer->say("$cUninstalled module(s) couldn't be imported", false);
        if ($cUninstalled > 0) {
            $printer->say(": " . implode(", ", $uninstalled));
        } else {
            $printer->say("");
        }

        //--------------------------------------------
        //
        //--------------------------------------------
        $alreadyInstalled = $summary->getAlreadyInstalledModules();
        $newlyInstalled = $summary->getNewlyInstalledModules();
        $uninstalled = $summary->getUninstalledModules();
        $successfullyUninstalled = $summary->getSuccessfullyUninstalledModules();


        $cAlready = count($alreadyInstalled);
        $printer->say("$cAlready module(s) were already installed", false);
        if ($cAlready > 0) {
            $printer->say(": " . implode(", ", $alreadyInstalled));
        } else {
            $printer->say("");
        }

        $cReinstalled = count($newlyInstalled);
        $printer->say("$cReinstalled module(s) have been newly installed", false);
        if ($cReinstalled > 0) {
            $printer->say(": " . implode(", ", $newlyInstalled));
        } else {
            $printer->say("");
        }

        $cUninstalled = count($uninstalled);
        $printer->say("$cUninstalled module(s) couldn't be installed", false);
        if ($cUninstalled > 0) {
            $printer->say(": " . implode(", ", $uninstalled));
        } else {
            $printer->say("");
        }

        $cUninstalled = count($successfullyUninstalled);
        $printer->say("$cUninstalled module(s) have been successfully uninstalled", false);
        if ($cUninstalled > 0) {
            $printer->say(": " . implode(", ", $successfullyUninstalled));
        } else {
            $printer->say("");
        }


    }


    $printer = ProgramPrinter::create();
    $appDir = getcwd();
    try {

        $modulesRelativePath = 'class-modules';

        $force = false;
        if (array_key_exists(2, $argv) && '-f' === $argv[2]) {
            $force = true;
            unset($argv[2]);
            $argv = array_merge($argv);
        }

        //--------------------------------------------
        // IMPORT
        // INSTALL
        // UNINSTALL
        //--------------------------------------------
        if (array_key_exists(1, $argv) &&
            ('import' === $argv[1] || 'install' === $argv[1] || 'uninstall' === $argv[1])
            && array_key_exists(2, $argv)
        ) {


            $isImport = ('import' === $argv[1]);
            $isUninstall = ('uninstall' === $argv[1]);


            $importerId = null;
            $moduleName = $argv[2];

            if (array_key_exists(3, $argv)) {
                $importerId = $argv[3];
            }


            $modulesDir = $appDir . "/" . $modulesRelativePath;

            if (false === file_exists($modulesDir)) {
                @mkdir($modulesDir, 0777, true);
            }


            if (file_exists($modulesDir)) {

                $summary = null;
                $kamille = KamilleNaiveImporter::create()
                    ->setProgramPrinter($printer)
                    ->forceImport($force)
                    ->setAppDir($appDir)
                    ->addImporter(KamilleWidgetsKamilleImporter::create())
                    ->setModulesRelativePath($modulesRelativePath);


                if (true === $isImport) {
                    $summary = $kamille->import($moduleName, $importerId);
                    printImportSummary($summary, $printer);
                } else {
                    if (true === $isUninstall) {
                        $summary = $kamille->uninstall($moduleName, $importerId);
                        printInstallSummary($summary, $printer, true);
                    } else {
                        $summary = $kamille->install($moduleName, $importerId);
                        printInstallSummary($summary, $printer);
                    }
                }
            } else {
                $printer->error("Cannot create the modules directory: $modulesDir");
            }

        }
        //--------------------------------------------
        // LIST
        //--------------------------------------------
        elseif (array_key_exists(1, $argv) && 'list' === $argv[1]) {
            $importerId = null;
            if (array_key_exists(2, $argv)) {
                $importerId = $argv[2];
            }
            KamilleNaiveImporter::create()
                ->setAppDir($appDir)
                ->setProgramPrinter($printer)
                ->addImporter(KamilleWidgetsKamilleImporter::create())
                ->listAvailableModules($importerId);

        } elseif (array_key_exists(1, $argv) && 'listimported' === $argv[1]) {
            KamilleNaiveImporter::create()
                ->setAppDir($appDir)
                ->setProgramPrinter($printer)
                ->addImporter(KamilleWidgetsKamilleImporter::create())
                ->listImportedModules();

        } elseif (array_key_exists(1, $argv) && 'listinstalled' === $argv[1]) {
            KamilleNaiveImporter::create()
                ->setAppDir($appDir)
                ->setProgramPrinter($printer)
                ->addImporter(KamilleWidgetsKamilleImporter::create())
                ->listInstalledModules();

        }
        //--------------------------------------------
        // SET/GET MODULES DIRECTORY RELATIVE PATH
        //--------------------------------------------
        elseif (array_key_exists(1, $argv) && 'setmodulesrelpath' === $argv[1] && array_key_exists(2, $argv)) {
            $path = $argv[2];
            if (true === ProgramStorage::create()->setModulesDirRelativePath($path)) {
                $printer->success("modules directory relative path successfully set");
            } else {
                $printer->error("modules directory relative path couldn't be set");
            }

        } elseif (array_key_exists(1, $argv) && 'getmodulesrelpath' === $argv[1]) {
            if (false !== ($path = ProgramStorage::create()->getModulesDirRelativePath())) {
                $printer->say($path);
            } else {
                $printer->error("modules directory relative path couldn't be retrieved. Please use the setmodulesrelpath command first");
            }

        }
        //--------------------------------------------
        // CLEAN
        //--------------------------------------------
        elseif (array_key_exists(1, $argv) && 'clean' === $argv[1]) {

            $appDir = getcwd();
            $modulesDir = $appDir . "/" . $modulesRelativePath;

            if (is_dir($modulesDir)) {
                CleanerTool::create()->setPrinter($printer)->clean($modulesDir);
                $printer->success('The following directory has been successfully cleaned: ' . $modulesDir . '');
            } else {
                $printer->error("The application modules directory doesn't exist. Please create it first, then re-execute this command. Expected path: $modulesDir");
            }
        } else {
            $printer->say("");
            $printer->error("Invalid arguments");
            $printer->help();
        }

    } catch (UserErrorException $e) {
        $printer->error($e->getMessage());
    }
}



